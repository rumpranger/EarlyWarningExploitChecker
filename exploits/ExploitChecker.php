<?php
/**
 * Exploit Checker Class
 *
 * Very basic exploit checker.
 * Attempts to download the url using curl (See: Curl Wrapper for details and options)
 * Checks donwloaded html for javascipt functions and iframes from untrusted sources
 * Be sure to modify the whitelist array to suit your need 
 * Any checks that you would like to skip can be bypassed by setting the skip code in the page request object. 
 * 
 * Written 05-08-2013
 * @author Charles Weiss
 * @package Exploits
 */
namespace Exploit;
use Exploit\CurlWrapper;
use Exploit\PageRequest;
use Exploit\ExploitResult;
class ExploitChecker
{
	private $hasExploit = false;
	/**
	 * Curl handler
	 * @var object
	 */
	private $ch = null;
	/**
	 * Whitelisted / Trusted domains we allow scripts / iframes from
	 * @var array
	 */
	private $_whitelist = array(
				"addthis.com", "cetrk.com", "google-analytics.com", "twitter.com", "facebook.com", "youtube.com"
			);

	/**
	 * List of errors generated
	 * @var array
	 */
	private $_errors = array();

	/**
	 * Constructor
	 */
	public function __construct()
	{
		$this->ch = new CurlWrapper();
	}

	/**
	 * Returns the list of errors in array form
	 */
	public function getErrors()
	{
		return $this->_errors;
	}

	/** 
	 * Process the provided url
	 * Runs a curl request to download the page 
	 * Checks the page's status
	 * Return error
	 */ 
	public function processUrl(PageRequest $page)
	{
		$this->appendToWhitelist($page);
		$res = $this->ch->createRequest($page->url);
		if ($res == false)
		{
			$this->hasExploit = true;
			$this->_errors[] = new ExploitResult('The following error occured downloading the url: ' . $this->ch->getErrString(), 999);
		}
		else
		{
			$status = $this->ch->getHttpStatus();
			$page->body = $this->ch->getWebpage();

			$this->checkForExploit($page);

			if ($status != 200)
			{
				$this->hasExploit = true;
				$this->_errors[] = new ExploitResult('HTTP status code warning: ' . $status, 999);
			}
		}

		return $this->hasExploit;
	}

	/**
	 * Cycle through the various check methods
	 * @param PageRequest $page
	 * @return boolean
	 */
	public function checkForExploit(PageRequest $page)
	{
		$this->hasParkedSuspendedExpiredString($page);
		$this->hiddenIframe($page);
		$this->hasEvalScript($page);
		$this->hasFunctionScript($page);
		$this->hasOffsiteScriptIframe($page);
		$this->hasParseScript($page);
		$this->hasUnescapeScript($page);
		$this->hasUrlencodedCurl($page);

		return $this->hasExploit;
	}

	/**
	 * Add the domain of the request to the whitelist array
	 * @param PageRequest $page
	 * @return boolean
	 */
	public function appendToWhitelist(PageRequest $page)
	{
		$this->_whitelist[] = $page->domain;
		$this->_whitelist = array_reverse($this->_whitelist);
		return true;
	}

	/**
	 * Check for script conataining parse function
	 * @param PageRequest $page
	 * @return boolean
	 */
	public function hasParseScript(PageRequest $page)
	{
		$code = 101;
		if (in_array($code, $page->toSkip))
			return false;
		$pattern = "/<script(.*?)parse(.*?)script>/i";
		if (preg_match($pattern, $page->body) != false)
		{
			$this->_errors[] = new ExploitResult('HTML contained script with parse function.', $code);
			$this->hasExploit = true;
			return true;
		}
		return false;
	}

	/**
	 * Check for script containing function
	 * @param PageRequest $page
	 * @return boolean
	 */
	public function hasFunctionScript(PageRequest $page)
	{
		$code = 102;
		if (in_array($code, $page->toSkip))
			return false;
		$pattern = "/<script(.*?)function(.*?)script>/i";
		if (preg_match($pattern, $page->body) != false)
		{
			$this->_errors[] = new ExploitResult('HTML contained script with function.', $code);
			$this->hasExploit = true;
			return true;
		}
		return false;
	}

	/**
	 * Check for script containing eval function
	 * @param PageRequest $page
	 * @return boolean
	 */
	public function hasEvalScript(PageRequest $page)
	{
		$code = 103;
		if (in_array($code, $page->toSkip))
			return false;
		$pattern = "/<script(.*?)eval(.*?)script>/i";
		if (preg_match($pattern, $page->body) != false)
		{
			$this->_errors[] = new ExploitResult('HTML contained script with eval function.', $code);
			$this->hasExploit = true;
			return true;
		}
		return false;
	}

	/**
	 * Check for script containing unescape function
	 * @param PageRequest $page
	 * @return boolean
	 */
	public function hasUnescapeScript(PageRequest $page)
	{
		$code = 104;
		if (in_array($code, $page->toSkip))
			return false;
		$pattern = "/\<script(.*?)unescape(.*?)script\>/i";
		if (preg_match($pattern, $page->body) != false)
		{
			$this->_errors[] = new ExploitResult('HTML contained script with unescape function.', $code);
			$this->hasExploit = true;
			return true;
		}
		return false;
	}

	/**
	 * Check for hideen iframe
	 * @param PageRequest $page
	 * @return boolean
	 */
	public function hiddenIframe(PageRequest $page)
	{
		$code = 201;
		if (in_array($code, $page->toSkip))
			return false;
		$pattern1 = "/<iframe(.*?)hidden(.*?)iframe>/i";
		$pattern2 = "/<iframe(.+?)hidden(.*?)\/>/i";
		if ((preg_match($pattern1, $page->body) != false) && (preg_match($pattern2, $page->body) != false))
		{
			$this->_errors[] = new ExploitResult('HTML contained hidden iframe.', $code);
			$this->hasExploit = true;
			return true;
		}
		return false;
	}

	/**
	 * Check for offsite script/iframe
	 * @param PageRequest $page
	 * @return boolean
	 */
	public function hasOffsiteScriptIframe(PageRequest $page)
	{
		$found = false;
		$patterns[105] = "/<script(.*?)src(.*?)http(.*?)script>/i";
		$patterns[106] = "/<script(.*?)src(.*?)http(.*?)\/>/i";
		$patterns[202] = "/<iframe(.*?)src(.*?)http(.*?)iframe>/i";
		$patterns[203] = "/<iframe(.*?)src(.*?)http(.*?)\/>/i";

		foreach ($patterns as $code => $pattern)
		{
			if (in_array($code, $page->toSkip))
				continue;

			preg_match_all($pattern, $page->body, $matches);
			if ((isset($matches[0])) && (!empty($matches[0])))
			{
				foreach ($matches[0] as $match)
				{
					$bad = true;
					foreach ($this->_whitelist as $dom)
					{
						if (($bad == false) || (stripos($match, $dom) !== false))
						{
							$bad = false;
						}
					}
					if ($bad == true)
					{
						$found = true;
						$this->hasExploit = true;
						$this->_errors[] = new ExploitResult('Offsite script/iframe found. (' . htmlentities($match) . ')', $code);
					}
				}
			}
		}
		return $found;
	}

	/**
	 * Check urlencoded curl request
	 * This is sometimes visible on pages where php is not parsed
	 * @param PageRequest $page
	 * @return boolean
	 */
	public function hasUrlencodedCurl(PageRequest $page)
	{
		$code = 301;
		if (in_array($code, $page->toSkip))
			return false;
		$pattern = "/\?ip\=\'\.urlencode/i";
		if (preg_match($pattern, $page->body) != false)
		{
			$this->_errors[] = new ExploitResult('Curl trojan found.', $code);
			$this->hasExploit = true;
			return true;
		}
		return false;
	}

	/**
	 * Check for suspended / expired / parked string
	 * @param PageRequest $page
	 * @return boolean
	 */
	public function hasParkedSuspendedExpiredString(PageRequest $page)
	{
		$code = 401;
		if (in_array($code, $page->toSkip))
			return false;
		$pattern = "/(suspended|expired|parked|buy this domain|domain for sale|domain is for sale|domain parking)/i";
		if (preg_match($pattern, $page->body) != false)
		{
			$this->_errors[] = new ExploitResult('Website appears to be Expired or Suspended or Parked.', $code);
			$this->hasExploit = true;
			return true;
		}
		return false;
	}
}
// End of Script
